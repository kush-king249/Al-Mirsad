#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Malware Analysis Module for Al-Mirsad
وحدة تحليل البرمجيات الخبيثة لأداة المرصاد

This module handles malware analysis using various techniques and sandbox environments.
تتعامل هذه الوحدة مع تحليل البرمجيات الخبيثة باستخدام تقنيات مختلفة وبيئات الحماية.
"""

import os
import hashlib
import logging
import subprocess
import json
import time
from typing import Dict, List, Optional, Tuple, Any
import requests


class MalwareAnalyzer:
    """
    Malware analysis class for analyzing suspicious files and behaviors.
    فئة تحليل البرمجيات الخبيثة لتحليل الملفات والسلوكيات المشبوهة.
    """
    
    def __init__(self, output_dir: str = "analysis_reports"):
        """
        Initialize the MalwareAnalyzer.
        
        Args:
            output_dir (str): Directory to store analysis reports
        """
        self.output_dir = output_dir
        self.logger = self._setup_logger()
        self._ensure_output_dir()
        
        # Known malware signatures (simplified for demo)
        self.malware_signatures = {
            'trojan': ['trojan', 'backdoor', 'keylogger'],
            'virus': ['virus', 'worm', 'infector'],
            'ransomware': ['encrypt', 'ransom', 'crypto'],
            'spyware': ['spy', 'monitor', 'track']
        }
    
    def _setup_logger(self) -> logging.Logger:
        """Setup logging for the module."""
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.INFO)
        
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)
        
        return logger
    
    def _ensure_output_dir(self):
        """Ensure output directory exists."""
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            self.logger.info(f"Created output directory: {self.output_dir}")
    
    def analyze_file(self, file_path: str, deep_analysis: bool = True) -> Dict[str, Any]:
        """
        Analyze a suspicious file for malware indicators.
        تحليل ملف مشبوه للبحث عن مؤشرات البرمجيات الخبيثة.
        
        Args:
            file_path (str): Path to the file to analyze
            deep_analysis (bool): Perform deep analysis including behavior analysis
            
        Returns:
            Dict[str, Any]: Analysis results
        """
        if not os.path.exists(file_path):
            self.logger.error(f"File not found: {file_path}")
            return {}
        
        self.logger.info(f"Starting analysis of file: {file_path}")
        
        analysis_results = {
            'file_path': file_path,
            'file_name': os.path.basename(file_path),
            'file_size': os.path.getsize(file_path),
            'analysis_timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'hash_analysis': {},
            'static_analysis': {},
            'dynamic_analysis': {},
            'threat_classification': {},
            'risk_score': 0
        }
        
        try:
            # Hash analysis
            analysis_results['hash_analysis'] = self._calculate_file_hashes(file_path)
            
            # Static analysis
            analysis_results['static_analysis'] = self._perform_static_analysis(file_path)
            
            # Dynamic analysis (if requested)
            if deep_analysis:
                analysis_results['dynamic_analysis'] = self._perform_dynamic_analysis(file_path)
            
            # Threat classification
            analysis_results['threat_classification'] = self._classify_threat(analysis_results)
            
            # Calculate risk score
            analysis_results['risk_score'] = self._calculate_risk_score(analysis_results)
            
            # Save analysis report
            self._save_analysis_report(analysis_results)
            
            self.logger.info(f"Analysis completed for {file_path}")
            
        except Exception as e:
            self.logger.error(f"Error analyzing file {file_path}: {str(e)}")
            analysis_results['error'] = str(e)
        
        return analysis_results
    
    def _calculate_file_hashes(self, file_path: str) -> Dict[str, str]:
        """Calculate various hashes for the file."""
        hashes = {}
        
        try:
            with open(file_path, 'rb') as f:
                file_data = f.read()
                
                # MD5
                hashes['md5'] = hashlib.md5(file_data).hexdigest()
                
                # SHA1
                hashes['sha1'] = hashlib.sha1(file_data).hexdigest()
                
                # SHA256
                hashes['sha256'] = hashlib.sha256(file_data).hexdigest()
                
            self.logger.info(f"Calculated hashes for {file_path}")
            
        except Exception as e:
            self.logger.error(f"Error calculating hashes: {str(e)}")
            
        return hashes
    
    def _perform_static_analysis(self, file_path: str) -> Dict[str, Any]:
        """Perform static analysis on the file."""
        static_results = {
            'file_type': '',
            'strings_analysis': [],
            'entropy': 0.0,
            'suspicious_imports': [],
            'suspicious_strings': []
        }
        
        try:
            # Detect file type
            static_results['file_type'] = self._detect_file_type(file_path)
            
            # Extract strings
            strings = self._extract_strings(file_path)
            static_results['strings_analysis'] = strings[:100]  # Limit to first 100 strings
            
            # Calculate entropy
            static_results['entropy'] = self._calculate_entropy(file_path)
            
            # Find suspicious strings
            static_results['suspicious_strings'] = self._find_suspicious_strings(strings)
            
            # Analyze imports (for PE files)
            if static_results['file_type'].lower() in ['pe', 'exe', 'dll']:
                static_results['suspicious_imports'] = self._analyze_imports(file_path)
            
            self.logger.info(f"Static analysis completed for {file_path}")
            
        except Exception as e:
            self.logger.error(f"Error in static analysis: {str(e)}")
            
        return static_results
    
    def _perform_dynamic_analysis(self, file_path: str) -> Dict[str, Any]:
        """Perform dynamic analysis (simulated sandbox analysis)."""
        dynamic_results = {
            'execution_attempted': False,
            'network_connections': [],
            'file_modifications': [],
            'registry_changes': [],
            'process_creation': [],
            'behavioral_indicators': []
        }
        
        try:
            # Note: This is a simplified simulation of dynamic analysis
            # In a real implementation, this would involve a proper sandbox environment
            
            self.logger.info(f"Performing dynamic analysis for {file_path}")
            
            # Simulate sandbox execution (DO NOT actually execute malware)
            dynamic_results['execution_attempted'] = True
            
            # Simulate behavioral analysis results
            file_name = os.path.basename(file_path).lower()
            
            # Check for suspicious file names
            suspicious_names = ['keylog', 'trojan', 'virus', 'malware', 'backdoor']
            for name in suspicious_names:
                if name in file_name:
                    dynamic_results['behavioral_indicators'].append(f"Suspicious filename: {name}")
            
            # Simulate network behavior
            if any(keyword in file_name for keyword in ['bot', 'trojan', 'backdoor']):
                dynamic_results['network_connections'] = [
                    {'ip': '192.168.1.100', 'port': 4444, 'protocol': 'TCP'},
                    {'ip': '10.0.0.50', 'port': 8080, 'protocol': 'HTTP'}
                ]
                dynamic_results['behavioral_indicators'].append("Suspicious network connections detected")
            
            # Simulate file system behavior
            if any(keyword in file_name for keyword in ['ransom', 'encrypt', 'crypto']):
                dynamic_results['file_modifications'] = [
                    {'action': 'encrypt', 'path': 'C:\\Users\\Documents\\*.doc'},
                    {'action': 'create', 'path': 'C:\\Users\\Desktop\\README.txt'}
                ]
                dynamic_results['behavioral_indicators'].append("File encryption behavior detected")
            
            self.logger.info(f"Dynamic analysis completed for {file_path}")
            
        except Exception as e:
            self.logger.error(f"Error in dynamic analysis: {str(e)}")
            
        return dynamic_results
    
    def _detect_file_type(self, file_path: str) -> str:
        """Detect file type using file command or magic bytes."""
        try:
            # Try using file command (Unix/Linux)
            result = subprocess.run(['file', file_path], capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip()
            
            # Fallback to magic bytes detection
            with open(file_path, 'rb') as f:
                magic_bytes = f.read(4)
                
                if magic_bytes.startswith(b'MZ'):
                    return 'PE executable'
                elif magic_bytes.startswith(b'\\x7fELF'):
                    return 'ELF executable'
                elif magic_bytes.startswith(b'PK'):
                    return 'ZIP archive'
                else:
                    return 'Unknown'
                    
        except Exception as e:
            self.logger.error(f"Error detecting file type: {str(e)}")
            return 'Unknown'
    
    def _extract_strings(self, file_path: str, min_length: int = 4) -> List[str]:
        """Extract printable strings from the file."""
        strings = []
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
                current_string = ""
                for byte in data:
                    if 32 <= byte <= 126:  # Printable ASCII
                        current_string += chr(byte)
                    else:
                        if len(current_string) >= min_length:
                            strings.append(current_string)
                        current_string = ""
                
                # Don't forget the last string
                if len(current_string) >= min_length:
                    strings.append(current_string)
            
            self.logger.info(f"Extracted {len(strings)} strings from {file_path}")
            
        except Exception as e:
            self.logger.error(f"Error extracting strings: {str(e)}")
            
        return strings
    
    def _calculate_entropy(self, file_path: str) -> float:
        """Calculate Shannon entropy of the file."""
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            if not data:
                return 0.0
            
            # Count byte frequencies
            byte_counts = [0] * 256
            for byte in data:
                byte_counts[byte] += 1
            
            # Calculate entropy
            entropy = 0.0
            data_len = len(data)
            
            for count in byte_counts:
                if count > 0:
                    probability = count / data_len
                    entropy -= probability * (probability.bit_length() - 1)
            
            return entropy
            
        except Exception as e:
            self.logger.error(f"Error calculating entropy: {str(e)}")
            return 0.0
    
    def _find_suspicious_strings(self, strings: List[str]) -> List[str]:
        """Find suspicious strings that might indicate malware."""
        suspicious = []
        
        suspicious_keywords = [
            'password', 'keylog', 'backdoor', 'trojan', 'virus',
            'encrypt', 'decrypt', 'ransom', 'bitcoin', 'wallet',
            'cmd.exe', 'powershell', 'registry', 'startup',
            'download', 'execute', 'inject', 'payload'
        ]
        
        for string in strings:
            string_lower = string.lower()
            for keyword in suspicious_keywords:
                if keyword in string_lower:
                    suspicious.append(string)
                    break
        
        return suspicious
    
    def _analyze_imports(self, file_path: str) -> List[str]:
        """Analyze imports for suspicious API calls (simplified)."""
        suspicious_imports = []
        
        # This is a simplified version - real implementation would use PE parsing libraries
        suspicious_apis = [
            'CreateProcess', 'WriteProcessMemory', 'VirtualAlloc',
            'SetWindowsHook', 'RegSetValue', 'InternetOpen',
            'CryptEncrypt', 'CryptDecrypt'
        ]
        
        try:
            strings = self._extract_strings(file_path)
            for string in strings:
                for api in suspicious_apis:
                    if api in string:
                        suspicious_imports.append(api)
                        
        except Exception as e:
            self.logger.error(f"Error analyzing imports: {str(e)}")
        
        return list(set(suspicious_imports))  # Remove duplicates
    
    def _classify_threat(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Classify the threat based on analysis results."""
        classification = {
            'threat_type': 'Unknown',
            'confidence': 0.0,
            'family': 'Unknown',
            'indicators': []
        }
        
        try:
            indicators = []
            
            # Check static analysis results
            static = analysis_results.get('static_analysis', {})
            
            # High entropy might indicate packing/encryption
            if static.get('entropy', 0) > 7.0:
                indicators.append('High entropy (possibly packed/encrypted)')
            
            # Check suspicious strings
            suspicious_strings = static.get('suspicious_strings', [])
            if suspicious_strings:
                indicators.extend([f"Suspicious string: {s}" for s in suspicious_strings[:5]])
            
            # Check suspicious imports
            suspicious_imports = static.get('suspicious_imports', [])
            if suspicious_imports:
                indicators.extend([f"Suspicious API: {api}" for api in suspicious_imports[:5]])
            
            # Check dynamic analysis results
            dynamic = analysis_results.get('dynamic_analysis', {})
            behavioral = dynamic.get('behavioral_indicators', [])
            if behavioral:
                indicators.extend(behavioral)
            
            # Classify based on indicators
            threat_scores = {}
            for threat_type, keywords in self.malware_signatures.items():
                score = 0
                for indicator in indicators:
                    indicator_lower = indicator.lower()
                    for keyword in keywords:
                        if keyword in indicator_lower:
                            score += 1
                threat_scores[threat_type] = score
            
            # Determine most likely threat type
            if threat_scores:
                best_match = max(threat_scores, key=threat_scores.get)
                if threat_scores[best_match] > 0:
                    classification['threat_type'] = best_match
                    classification['confidence'] = min(threat_scores[best_match] / 10.0, 1.0)
            
            classification['indicators'] = indicators
            
        except Exception as e:
            self.logger.error(f"Error classifying threat: {str(e)}")
        
        return classification
    
    def _calculate_risk_score(self, analysis_results: Dict[str, Any]) -> int:
        """Calculate overall risk score (0-100)."""
        score = 0
        
        try:
            # Static analysis factors
            static = analysis_results.get('static_analysis', {})
            
            # High entropy
            if static.get('entropy', 0) > 7.0:
                score += 20
            
            # Suspicious strings
            suspicious_strings = len(static.get('suspicious_strings', []))
            score += min(suspicious_strings * 2, 20)
            
            # Suspicious imports
            suspicious_imports = len(static.get('suspicious_imports', []))
            score += min(suspicious_imports * 3, 15)
            
            # Dynamic analysis factors
            dynamic = analysis_results.get('dynamic_analysis', {})
            behavioral = len(dynamic.get('behavioral_indicators', []))
            score += min(behavioral * 5, 25)
            
            # Network connections
            network = len(dynamic.get('network_connections', []))
            score += min(network * 5, 10)
            
            # File modifications
            file_mods = len(dynamic.get('file_modifications', []))
            score += min(file_mods * 3, 10)
            
            # Threat classification confidence
            threat = analysis_results.get('threat_classification', {})
            confidence = threat.get('confidence', 0)
            if confidence > 0.5:
                score += 20
            
        except Exception as e:
            self.logger.error(f"Error calculating risk score: {str(e)}")
        
        return min(score, 100)
    
    def _save_analysis_report(self, analysis_results: Dict[str, Any]):
        """Save analysis report to file."""
        try:
            file_name = analysis_results.get('file_name', 'unknown')
            timestamp = analysis_results.get('analysis_timestamp', '').replace(':', '-').replace(' ', '_')
            report_file = os.path.join(self.output_dir, f"analysis_{file_name}_{timestamp}.json")
            
            with open(report_file, 'w', encoding='utf-8') as f:
                json.dump(analysis_results, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Analysis report saved to {report_file}")
            
        except Exception as e:
            self.logger.error(f"Error saving analysis report: {str(e)}")
    
    def analyze_directory(self, directory_path: str, file_extensions: List[str] = None) -> List[Dict[str, Any]]:
        """
        Analyze all files in a directory.
        تحليل جميع الملفات في مجلد.
        
        Args:
            directory_path (str): Path to directory to analyze
            file_extensions (List[str]): File extensions to analyze (None for all)
            
        Returns:
            List[Dict[str, Any]]: List of analysis results
        """
        if file_extensions is None:
            file_extensions = ['.exe', '.dll', '.bat', '.ps1', '.scr', '.com']
        
        results = []
        
        if not os.path.exists(directory_path):
            self.logger.error(f"Directory not found: {directory_path}")
            return results
        
        try:
            for root, dirs, files in os.walk(directory_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    file_ext = os.path.splitext(file)[1].lower()
                    
                    if file_ext in file_extensions:
                        self.logger.info(f"Analyzing file: {file_path}")
                        result = self.analyze_file(file_path)
                        if result:
                            results.append(result)
            
            self.logger.info(f"Directory analysis completed: {len(results)} files analyzed")
            
        except Exception as e:
            self.logger.error(f"Error analyzing directory {directory_path}: {str(e)}")
        
        return results
    
    def generate_summary_report(self, analysis_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Generate a summary report from multiple analysis results.
        إنشاء تقرير موجز من نتائج تحليلات متعددة.
        
        Args:
            analysis_results (List[Dict[str, Any]]): List of analysis results
            
        Returns:
            Dict[str, Any]: Summary report
        """
        summary = {
            'total_files_analyzed': len(analysis_results),
            'high_risk_files': [],
            'medium_risk_files': [],
            'low_risk_files': [],
            'threat_types_found': {},
            'average_risk_score': 0.0,
            'recommendations': []
        }
        
        try:
            total_risk_score = 0
            
            for result in analysis_results:
                risk_score = result.get('risk_score', 0)
                total_risk_score += risk_score
                
                file_info = {
                    'file_name': result.get('file_name', 'Unknown'),
                    'risk_score': risk_score,
                    'threat_type': result.get('threat_classification', {}).get('threat_type', 'Unknown')
                }
                
                # Categorize by risk level
                if risk_score >= 70:
                    summary['high_risk_files'].append(file_info)
                elif risk_score >= 40:
                    summary['medium_risk_files'].append(file_info)
                else:
                    summary['low_risk_files'].append(file_info)
                
                # Count threat types
                threat_type = file_info['threat_type']
                if threat_type != 'Unknown':
                    summary['threat_types_found'][threat_type] = summary['threat_types_found'].get(threat_type, 0) + 1
            
            # Calculate average risk score
            if analysis_results:
                summary['average_risk_score'] = total_risk_score / len(analysis_results)
            
            # Generate recommendations
            if summary['high_risk_files']:
                summary['recommendations'].append("Immediately quarantine high-risk files")
            if summary['medium_risk_files']:
                summary['recommendations'].append("Review and analyze medium-risk files")
            if summary['threat_types_found']:
                summary['recommendations'].append("Update antivirus signatures for detected threat types")
            
        except Exception as e:
            self.logger.error(f"Error generating summary report: {str(e)}")
        
        return summary
